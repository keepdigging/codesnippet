### kmp algorithm

#### principle

#### pseudo code

#### code with java


#### test case


#### time & space complexity.

---

#### 算法本质

    这个算法针对的是子串有对称属性,如果有对称属性,那么要向前查找是否有可以再次匹配的内容
    next[]描述的是子串的对称程度,程度越高,值越大,可能出现再匹配的机会就更大
    (不是中心对称,而是中心字符块对称,比如不是abccba,而是abcabc这种对称)
    
    失配后move多少呢? 失配位j之前已经匹配的字符长度-next[j]值; 
    如果对称程度越高,next[j]值越大,即移动的位越小因为可能再次出现匹配的情况.
    如果没有对称,则移动最大,即直接跳过

#### 数学归纳法

    0.初始条件next[0]=0
    1.假设next[j]=k成立
    2.推到next[j+1]=?
        2.1 如果pattern[k]==pattern[j] 推出 next[j+1]=k+1
        2.1 如果pattern[k]!=pattern[j] 递归 k=next[k] 直到k=0

#### 图形化描述

   [KMP算法的Next数组详解](http://www.cnblogs.com/tangzhengyue/p/4315393.html)
   ![](https://images0.cnblogs.com/blog2015/326320/201503/051048038058339.png)

#### 代码实现

    private static int[] next(char[] pattern)
    {
        int[] nextArr = new int[pattern.length];
        nextArr[0] = 0;

        int j, k;//q:模版字符串下标；k:最大前后缀长度

        for (j = 1,k = 0; j < pattern.length; ++j)
        {
            while(k > 0 && pattern[j] != pattern[k])
                k = nextArr[k-1];
            if (pattern[j] == pattern[k])//如果相等，那么最大相同前后缀长度加1
            {
                k++;
            }
            nextArr[j] = k;
        }
        return nextArr;
    }

---

#### 另一种解释

    a、当前一个字符的对称程度为0的时候，只要将当前字符与子串第一个字符进行比较。这个很好理解啊，前面都是0，说明都不对称了，
    如果多加了一个字符，要对称的话最多是当前的和第一个对称。比如agcta这个里面t的是0，那么后面的a的对称程度只需要看它是不是等于第一个字符a了。
    b、按照这个推理，我们就可以总结一个规律，不仅前面是0呀，如果前面一个字符的next值是1，那么我们就把当前字符与子串第二个字符进行比较，
    因为前面的是1，说明前面的字符已经和第一个相等了，如果这个又与第二个相等了，说明对称程度就是2了。有两个字符对称了。比如上面agctag，
    倒数第二个a的next是1，说明它和第一个a对称了，接着我们就把最后一个g与第二个g比较，又相等，自然对称成都就累加了，就是2了。
    c、按照上面的推理，如果一直相等，就一直累加，可以一直推啊，推到这里应该一点难度都没有吧，如果你觉得有难度说明我写的太失败了。
    当然不可能会那么顺利让我们一直对称下去，如果遇到下一个不相等了，那么说明不能继承前面的对称性了，
    这种情况只能说明没有那么多对称了，但是不能说明一点对称性都没有，所以遇到这种情况就要重新来考虑，这个也是难点所在。

    回头来找对称性
    这里已经不能继承前面了，但是还是找对称串嘛，最愚蠢的做法大不了写一个子函数，查找这个字符串的最大对称程度，怎么写方法很多吧，
    比如查找出所有的当前字符串，然后向前走，看是否一直相等，最后走到子串开头，当然这个是最蠢的，我们一般看到的KMP都是优化过的，
    因为这个串是有规律的。
    在这里依然用上面表中一段来举个例子：   
    位置i=0到14如下,我加的括号只是用来说明问题：
    (a g c t a g c )( a g c t a g c) t
    我们可以看到这段，最后这个t之前的对称程度分别是：1，2，3，4，5，6，7,倒数第二个c往前看有7个字符对称，所以对称为7。
    但是到最后这个t就没有继承前面的对称程度next值，所以这个t的对称性就要重新来求。
    这里首要要申明几个事实
    1、t 如果要存在对称性，那么对称程度肯定比前面这个c 的对称程度小，所以要找个更小的对称，这个不用解释了吧，如果大那么t就继承前面的对称性了。
    2、要找更小的对称，必然在对称内部还存在子对称，而且这个t必须紧接着在子对称之后。

    [KMP算法的前缀next数组最通俗的解释](https://www.cnblogs.com/ganhang-acm/p/4060508.html)

    ![](http://hi.csdn.net/attachment/201108/29/0_1314610552Nj5Q.gif)
    ![](http://hi.csdn.net/attachment/201108/29/0_1314610574Rjbs.gif)

    从上面的理论我们就能得到下面的前缀next数组的求解算法

    void SetPrefix(const char *Pattern, int prefix[])
    {
         int len=CharLen(Pattern);//模式字符串长度。
         prefix[0]=0;
         for(int i=1; i<len; i++)
         {
             int k=prefix[i-1];
             //不断递归判断是否存在子对称，k=0说明不再有子对称，
             Pattern[i] != Pattern[k]说明虽然对称，但是对称后面的值和当前的字符值不相等，所以继续递推
             while( Pattern[i] != Pattern[k]  &&  k!=0 )               
                 k=prefix[k-1];     //继续递归
             if( Pattern[i] == Pattern[k])//找到了这个子对称，或者是直接继承了前面的对称性，这两种都在前面的基础上++
                  prefix[i]=k+1;
             else
                  prefix[i]=0;       //如果遍历了所有子对称都无效，说明这个新字符不具有对称性，清0
         }
    }










